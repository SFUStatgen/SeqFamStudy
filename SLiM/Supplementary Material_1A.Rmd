---
title: "Supplementary Material 1-A: Simulate SNV sequence data for pedigree founders"
author: "Nirodha Epasinghege Dona, Jinko Graham"
date: "`r Sys.Date()`"
bibliography: MyCollection.bib
output: 
 pdf_document:
   extra_dependencies: ["float"]
   number_sections: true
   toc: true # table of content true
   toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
   highlight: tango  # specifies the syntax highlighting style
header-includes:
        - \usepackage{xcolor,colortbl}
        - \usepackage{listings}
        - \usepackage{amsmath}
        - \usepackage{multirow}
        - \usepackage{makeidx}
        - \usepackage{microtype}
        - \usepackage[backend=bibtex,style=nature,maxcitenames=1, maxbibnames=1]{biblatex}
        - \usepackage{hyperref}
        - \usepackage{float}
        - \usepackage{caption}
        - \usepackage{blindtext}
        - \usepackage{graphicx}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

\newpage


- This is the first RMarkdown document in a sequence describing how we simulated exome-sequencing data in pedigrees ascertained for three or more relatives affected with lymphoid cancer. The following flow chart illustrates the overall workflow for this project. 

\begin{figure}[H]
	\centering
	\includegraphics[height = 1 \textwidth , width = 2 \textwidth]{Flow Chart.pdf}
	\caption{Flow chart showing the overall work flow for simulating the exome-sequencing data for ascertained pedigrees.}
	\label{flow chart}
\end{figure}

- In this RMarkdown document, we focus on the part of the flowchart labelled as 1 (the green box).
To start, we require single-nucleotide variant (SNV) sequences for pedigree founders. These founders are 
assumed to be sampled from an American Admixed population, which we simulate with the evolutionary 
simulation package \texttt{SLiM} [@Haller2019a]. In particular, we simulate genome-wide sequences
of exons only, to mimic exome sequencing.

- The outline of this document as follows. Section 1 explains the demographic model for the source
population of the pedigree founders. Section 2 explains how we create the \texttt{SLiM} recombination 
map using the \texttt{create\_SlimMap()} function in the \texttt{SimRVSequence} R package [@Nieuwoudt2020]. 
Section 3 discusses how we set the parameters in our SLiM model to simulate the exon-only SNV sequences. 

- The final outcome of this RMarkdown document is the \texttt{SLiM\_output} sequences file called by our third RMarkdown document. This sequences file is used to generate the exome-sequencing data in the family-based 
study of lymphoid cancer families. 

# Explain the demographic model

- Demographic models play a major role in understanding the genetic patterns in human populations. 
Throughout human evolution, different demographic events such as expansion, migration, splitting etc. 
have occurred, affecting genetic diversity [@Ragsdale2019]. The population-genetics literature has
several established demographic models inferred from genetic data [@Gutenkunst2009]. Some of these
models have been compiled in \texttt{stdpopsim}, the standard library of population-genetic 
simulation models [@10.7554/eLife.54967]. At the time of writing, this library contains around 
nine demographic models.  Among these, we select the **American Admixture** demographic 
model of @Browning2018 because the family-based study motivating our work
is in a North American population. We next explain details of the American admixture demographic model.

## American admixture demographic model

- In the American-Admixture model [@Browning2018], the pre-admixture model parameters are selected from the Out-of-Africa model of @Gravel2011. The following figure illustrates the Out-of-Africa model.

 \begin{figure}[H]
\centering
\includegraphics[height = 0.9\textwidth , width = 1 \textwidth ]{Out of Africa model.jpg}
	\caption{The inferred Out-of-Africa demographic model.}
	\label{outof africa model}
\end{figure}


- In the figure, note that the parameter estimates have been rounded. The model has three populations representing Africa, Europe and Asia. The initial effective population size of Africa was $7310$ individuals which then increased to $14,474$ individuals $5920$ generations ago.  About $2040$ generations ago the out-of-Africa migration event occurred with a migrating effective population size of $1861$ individuals. Then migration occurred between Africa and out-of-Africa populations with a rate of $1.5 \times 10^{-4}$ per generation. About 920 generations ago, the out-of-Africa population split into two populations, Europe and Asia, with effective sizes of $1032$ and $554$ individuals, respectively. These two populations then grew at rates of $3.8 \times 10^{-3}$ per generation for Europe and $4.8 \times 10^{-3}$ per generation for Asia. Further, between these three populations, (Africa , Europe and Asia) migrations occurred. The migration rates per generation were $2.5 \times 10^{-5}$ between Africa and Europe, $7.8 \times 10^{-6}$ between Africa and Asia, and $3.11 \itme 10^{-5}$ between Europe and Asia [@Browning2018].
Admixing started $12$ generations ago with the initial effective size of the admixed population being $30,000$ individuals. The growth rate of the admixed population was $5\%$ per generation with $\frac{1}{6}$ of the 
admixed population originating from African ancestry, $\frac{1}{3}$ from European ancestry and $\frac{1}{2}$ 
from Asian ancestry [@Browning2018]. 
  
- We use the inferred American-admixture demographic model and discuss how to set it up in SLiM in section 3.
  
- In the next section, we discuss how to create the recombination map required for the SLiM simulation. 


# Create recombination map for SLiM

- To simulate the genome-wide exon-only SNVs from SLiM, we need to supply a recombination map which reads the exon positions in chromosomes. We use the \texttt{create\_SlimMap()} function in the \texttt{SimRVSequence} [@Nieuwoudt2020] R package for this as shown in the next code chunk
  
```{r}
library(SimRVSequences)

# Load hg_exons data set in SimRVSequence package
data("hg_exons")

# Create recombination map for exon-only data using the hg_exons dataset
s_map <- create_slimMap(exon_df = hg_exons)
head(s_map)

```

- We use the \texttt{hg\_exons} data set in the \texttt{SimRVSequence} package.
  
- The hg38 reference genome with the UCSC Genome Browser is used to collect the data in \texttt{hg\_exons} [@Nieuwoudt2020].
  
- The \texttt{hg\_exons} data set presents the positions of each of the 22 human autosomes.
  
- By supplying the \texttt{hg\_exons} data set to the \texttt{create\_SlimMap()} function, we get the recombination map required for the SLiM model.
  
- As shown in the above output of this function, it returns a data frame describing the information about the genetic segments in each chromosome. 
  
- As an example, the first row in the output above represents information about the genetic segment before the first exon on chromosome 1. 

- The second row represents information about the first exon on chromosome 1. The exon contains 354 base pairs and the recombination and mutation rates of this exon is $10^{-8}$ per site per generation. The other columns of the data frame are described in the \texttt{SimRVSequences} documentation. 
  
- The recombination between adjacent exons is set to the number of base pairs in the segment (\texttt{segLength}) multiplied by $10^{-8}$ per base pair per generation (\texttt{recomb\_rate}). Further, the gap between two unlinked chromosomes is defined as 1 base pair and the recombination rate between them is set to 0.5 per base pair per generation [@Harris2016]. 

- Since we are interested in exon-only data, the mutation rate outside exons is set to zero and mutation rates inside exons is set to $10^{-8}$ per base pair per generation [@Nieuwoudt2020].
  
- From the output of \texttt{create\_SlimMap()}, we need three variables to create the recombination map for simulating exon-only data by SLiM: \texttt{recRate},\texttt{mutRate} and \texttt{endPos}.
  
- We select these three variables from the above output to supply the recombination map to SLiM. Also, it is important to shift the \texttt{endPos} variable forward 1 unit, because the \texttt{Eidos} scripting language in SLiM, reads arrays starting position as 0 instead 1.

```{r}

# Restrict output to the variables required by SLiM
slimMap <- s_map[, c("recRate", "mutRate", "endPos")]

# Shift endPos up by one unit
slimMap$endPos <- slimMap$endPos - 1

# Print first four rows of slimMap
head(slimMap, n = 4)

# Write the results to a text file
write.table(slimMap, file ="Slim_Map_chr.txt")

```


- As shown in the above R code chunk, we select only the three variables which are required for the recombination map in the SLiM simulation.
  
- We save the resulting output as a text file (\texttt{Slim\_Map\_chr.txt}) which we can use as our recombination map to read in SLiM.
  
- In the next section, we describe our SLiM model which we use to simulate exon-only SNV data for our population of unrelated pedigree founders.

# Simulate the demographic model in SLiM
  
- The SLiM manual [@Haller2019a] explains the Out-of-Africa model of @Gravel2011.
  
- We use this Out-of-Africa SLiM script to develop the American admixture model explained in @Browning2018. 
  
- The following SLiM script is for the American admixture model. 

- Let's discuss the SLiM model in more detail.

- Note: The following code chunk is not in R but rather is a \texttt{.slim} file. To provide a clear representation of the SLiM script to the readers, we use an R code chunk to represent it. However, you can find the original \texttt{SLiM\_American\_Admixture.slim} file in our GitHub page.


```{r, eval = FALSE}

initialize() {

// Seed number which helps to repoduce the same result
setSeed(2181144364021)
  
// Read recombination map cretated by SimRVSequence R package

lines = readFile("~/Slim_Map_chr.txt");
Rrates = NULL;
Mrates = NULL;
ends = NULL;

for (line in lines)
{
components = strsplit(line);
ends = c(ends, asInteger(components[3]));
Rrates = c(Rrates, asFloat(components[1]));
Mrates = c(Mrates, asFloat(components[2]));
}
Exomelength = ends[size(ends)-1];

initializeRecombinationRate(Rrates, ends);

initializeMutationRate(Mrates, ends);

initializeSex("A"); // Specifies modeling of an autosome

initializeMutationType("m1", 0.5, "g", -0.043, 0.23); //non-synonymous
initializeMutationType("m2", 0.5, "f", 0.0); // synonymous

m1.mutationStackPolicy = "l";
m2.mutationStackPolicy = "l";

initializeGenomicElementType("g1", m1, 1); // positions 1 and 2
initializeGenomicElementType("g2", m2, 1); // positions 3

starts = repEach(seqLen(asInteger(round(Exomelength/3))) * 3, 2) +
  rep(c(0,2), asInteger(round(Exomelength/3)));
end_pos = starts + rep(c(1,0), asInteger(round(Exomelength/3)));
types = rep(c(g1,g2), asInteger(round(length(starts)/2)));

initializeGenomicElement(types, starts, end_pos);

}

// Initialize the ancestral African population
1 { sim.addSubpop("p1", asInteger(round(7310.370867595234))); }

// End the burn-in period; expand the African population
73105 { p1.setSubpopulationSize(asInteger(round(14474.54608753566))); }

// Split Eurasians (p2) from Africans (p1) and set up migration
76968 {
sim.addSubpopSplit("p2", asInteger(round(1861.288190027689)), p1);
p1.setMigrationRates(c(p2), c(15.24422112e-5));
p2.setMigrationRates(c(p1), c(15.24422112e-5));
}

// Split p2 into European (p2) and East Asian (p3); resize; migration
78084 {
sim.addSubpopSplit("p3", asInteger(round(553.8181989)), p2);
p2.setSubpopulationSize(asInteger(round(1032.1046957333444)));
p1.setMigrationRates(c(p2, p3), c(2.54332678e-5, 0.7770583877e-5));
p2.setMigrationRates(c(p1, p3), c(2.54332678e-5, 3.115817913e-5));
p3.setMigrationRates(c(p1, p2), c(0.7770583877e-5, 3.115817913e-5));
}

// Set up exponential growth in Europe (p2) and East Asia (p3)
78084:79012{
t = sim.generation - 78084;
p2_size = round(1032.1046957333444 * (1 + 0.003784324268)^t);
p3_size = round(553.8181989 * (1 + 0.004780219543)^t);
p2.setSubpopulationSize(asInteger(p2_size));
p3.setSubpopulationSize(asInteger(p3_size));
}

// Create the admix population
79012 early(){
sim.addSubpop("p4", 30000); //This new subpopulation is created with 30000 new empty individuals
p4.setMigrationRates(c(p1, p2, p3), c(0.1666667, 0.3333333, 0.5));
}

//After this early() event, SLiM will generate offspring, and the empty individuals in p4 will be
// discarded and replaced by migrant offspring from p1, p2 and p3 as requested.
79012 late(){
p4.setMigrationRates(c(p1, p2, p3), c(0, 0, 0));
}

// Set up exponential growth in admixture (p4)
79012:79024 {
t = sim.generation - 79012;
p4_new_size = round(30000 * (1 + 0.05)^t);
p4.setSubpopulationSize(asInteger(p4_new_size));
}

// Output and terminate
79024 late() {
p4.individuals.genomes.output(filePath = "~/Output_Full.txt");
}

```

- In SLiM modelling, the first step is to initialize the required parameters to begin the simulation.
  
- The \texttt{initialize()} callback does this task.

- Before the simulation starts, we need to initialize the mutation rate, recombination rate, genomic structure and so forth as the simulation parameters [@Haller2019a].
  
- Let's discuss the \texttt{initialize()} callbacks in our SLiM model.
  
- Our first step inside this \texttt{initialize()} callback is to load the recombination map we designed in R using the \texttt{create\_SlimMap()} function.
  
- We read the recombination map into SLiM using the \texttt{readFile()} function. Inside this function, we supply the path to our recombination map text file.
  
- Then we create three null vectors named as \texttt{Rrates}, \texttt{Mrates} and \texttt{ends} to save the recombination rates, mutation rates and end positions of each exon in our recombination map, respectively. 
  
- We use a \texttt{for} loop to read each line of the loaded text file of our recombination map and save the three variables in the above mentioned three vectors.
  
- We initialize the recombination rates along the whole exome. The \texttt{initializeRecombinationRate()} function is used to specify the recombination rates and end positions of these rates. The first parameter is the recombination rates and the second parameter is the positions of the exons on the chromosomes.
  
- We initialize the mutation rates as well. The  \texttt{initializeMutationRate()} function is used for this task. 
  
- \texttt{initializeMutationRate()} initializes the mutation rates along the chromosomes. 
  
- Inside the  \texttt{initializeMutationRate()} function, we use the the vector of mutation rates along the chromosomes as the first parameter and the positions of the exons in the chromosomes as the second parameter.
  
- The \texttt{initializeSex()} function defines the type of the chromosome that we need to simulate. Since we model autosomes we define it as "A". 
  
- The next initialization callback is the mutation type. For this, first we use the \texttt{initializeMutationType()} function to create different types of mutations.
  
- In exons, the last base-pair position in a 3 base-pair "codon" (coding for an amino acid in a protein) is called a synonymous site. 
  
- Synonymous sites are viewed as selectively neutral in comparison to the first two base-pair positions in a codon which are non-synonymous. 
  
- Therefore, we simulate two types of mutations here. They are synonymous and non-synonymous.
  
- The \texttt{initializeMutationType}("m1", 0.5, "g", -0.043, 0.23) callback explains all the parameters that are held by the "m1" mutation type. 
  
- We use "m1" to represent the non-synonymous mutations. These non-synonymous mutations have a dominance coefficient of 0.5 and the selection coefficient is generated from a gamma distribution with mean -0.043 and shape parameter is 0.23 [@Harris2016].
 
- Then for the synonymous mutations, we again initialize them separately by using another \texttt{initializeMutationType} function. 

- In \texttt{initializeMutationType}("m2", 0.5, "f", 0.0), the "m2" mutation type represents the synonymous mutations and they have a fixed selection coefficient denoted by "f". The selection coefficient of this type of mutations is always 0, as seen in the fourth argument of the function. The dominance coefficient in the second argument is 0.5.
 
- In SLiM (as in biology), mutations themselves are not under selection; individuals are under selection. The selection is done based on the fitness value of the individuals.

- The fitness value of an individual is calculated from the fitness effects of all mutations carried by that individual (based upon selection coefficient, dominance coefficient, and heterozygous/homozygous state). All the fitness effects get multiplied together to produce the individual fitness.
 
- The individual fitness value then affects selection; in Wright-Fisher (WF) models (this is the default setting in SLiM), lower fitness means a lower probability of mating. 

- Our simulation is designed under the default model, the Wright-Fisher model.
 
- As a result, deleterious mutations tend to decrease in frequency and beneficial mutations tend to increase in frequency. 
 
- In SLiM recurrent mutations at a given base position can occur [@Haller2019a].

- In SLiM the default behavior is "mutation stacking" referred to as "s"(stacked). In our model this default behavior is changed to "l" (last) with the command \texttt{m1.mutationStackPolicy = "l"}, so that new mutations occurring in the same location as pre-existing mutations on a given genome replace the pre-existing mutations.

- The next initialization task is to create the chromosome structure. In SLiM we can model different genomic structures in the chromosomes.

- In our study, we only consider the exons in our chromosomes. 

- Exons have two genomic element types, one for non-synonymous sites (positions 1 and 2 of the resulting codon) and the other for synonymous sites (position 3 of the resulting codon).

- We called these genomic element types "g1" and "g2" and they would alternate as g1, g2, g1, g2, g1, etc. along the exome until the end position of a chromosome is reached. 

- The first genomic element type (corresponding to the non-synonymous sites) could have mutations with selection coefficients that come from the negative gamma distribution (which we initialize as "m1" to represent the non-synonymous mutations). 

- The second genomic element type (corresponding to the synonymous sites) could have neutral mutations (which we initialize as "m2" to represent the synonymous mutations).

- We use the \texttt{initializeGenomicElementType()} function to specify these two genomic elements and our exome structure.

- \texttt{initializeGenomicElementType("g1", m1, 1)} specifies that genomic element type "g1" is defined as using mutation type "m1" for all of its mutations.

- We define the second genomic element type "g2" using mutation type "m2" for all its mutations.

- Then we code to create the exome structure creating start and end positions of "g1" and "g2" genomic elements.

- As the final initialization task, we initialize the two genomic elements "g1" and "g2" with \texttt{initializeGenomicElement()}, supplying their starting and ending positions along the exome. 

- After the \texttt{initialize()} callbacks end, we run the first generation of our simulation. 

- We use the Out-of-Africa model of @Gravel2011 that is described in the SLiM manual [@Haller2019a].  Note that the SLiM manual uses the exact parameter estimates from the original model described in @Gravel2011.

- In the first generation the first sub population is created with the inferred initial size and we label it as "p1". 

- We use the function \texttt{sim.addSubpop()} to add "p1", the new sub population, by giving its initial size.

- @Haller2019a start the model at 79024 generations back (approximately 1.98 million years); this is generation 0 in the model.

- The model then takes 10*\texttt{African ancestral population size} generations as the neutral burn-in time [@Haller2019a]. An expansion of the African population occurs at 73105 generations. 

- Therefore, at 73105 generations, we change the sub-population size of "p1" (Africa) from $\sim7310$ to $\sim14474$. 

- After this event, at generation 76968, the African sub-population splits into the Eurasian ancestral sub-population.  

- We create another sub-population, "p2", to represent the Eurasian ancestral sub-population and migration is started between these two populations [@Haller2019a].


- \texttt{p1.setMigrationRates} sets the migration rate from the African to the Eurasian ancestral sub-population, while \texttt{p2.setMigrationRates} sets the migration rate from the Eurasian ancestral to the African sub-population. 

- Then at 78084 generations, the "p2" Eurasian sub-population splits into European and Asian sub-populations. Therefore, we create a new sub-population,"p3", to represent the Asian sub-population. The Eurasian ancestral sub-population becomes the European sub-population.


- After that, we set the migration rates between three sub-populations accordingly.

- Then we set up exponential growth in European (p2) and Asian (p3) sub-populations starting from 78084 generations to 79012 generations. 

- At 79012 generations, we create our admixed sub-population with an initial size 30000 and set the migration rates between the admixed and the other three sub-populations as given in @Browning2018. After we create the admixed sub-population, we stop all migrations.

- Then between 79012 to 79024 generations we set exponential growth of this admixed sub-population with a rate of 5% (individuals per generation). 

- Finally in generation 79024 we terminate our SLiM simulation and collect our output from the model.

- Since our main study is based on the Northern American population, we only consider the American admixed sub-population as the output. 

- Therefore, we use the function \texttt{p4.individuals.genomes.output()} to get the all individual's genomes of the admixed sub-population. 

- The following example represents the format of the output returned from the \texttt{p4.individuals.genomes.output()} function.

\textbf{\#OUT: 79024 GS 107752 /project/6007536/epasiedn/SLiM/American\_Admixture/Output\_Full.txt} \newline
Mutations: \newline
7229 50171 m2 51287555 0 0.5 p1 5 60626 ...\newline
13218 484904 m2 39812003 0 0.5 p1 45 9536 ... \newline
5202 762125 m2 36490340 0 0.5 p1 70 64099 ... \newline
... \newline
Genomes: \newline
p\*:0 A 0 1 2 3 4 5 6 7 8 9 10 11 ... \newline
p\*:1 A 10605 1 2 3 10606 4 5 6 8 10607 10608 9 ... \newline
p\*:2 A 10605 1 2 4 15639 15640 6 10608 15641 15642 15643 15644\newline
p\*:3 A 0 1 2 19096 19097 4 6 19098 19099 9 10 19100\newline
...

- In the above example output, the first row starts with \# OUT: and this is followed by the generation (79024) in which the output is generated. Then "GS" represents the "genomes SLiM format" and this is followed by the sample size in number of genomes (2* number of individuals). Finally, the full path where we save the output is printed.

- Then the second line starts the mutation section.

- In the mutation section each row represents a mutation which is currently segregating in the population and the nine columns represent the mutation properties. 

- The first column is the SLiM-generated identifier number which helps to identify the mutation easily. The second column is the mutation's identification number. The third field represents the type of the mutation. The fourth column is the base-pair position of the mutation on the chromosome. Fifth and sixth columns represent selection and dominance coefficients, respectively. The seventh column is the sub-population in which the mutation originated. The eighth column is the generation when the mutation
arose. Finally, the ninth column represents the number of copies of the mutation in the sub-population. 

- The last section in the output represents the genomes section. 

- In the genome section a row corresponds to a genome in the sub-population and specifies all the mutations carried by the genome. 

- Because we use \texttt{p4.individuals.genomes.output()}, we get all the genomes in p4 sub-population. The first line in the genomes section in the above example, "p\*: 0", means the 0th genome of the sub-population . Then "A" represents autosome, the type of the genome. This is followed by the SLiM-generated identification numbers of all the mutations carried by this genome. Recall that the SLiM-generated identification numbers are in the first column in the mutation section. 

## Simulation on Compute Canada Cluster

- This SLiM simulation is highly memory intensive and not suitable for most personal computers. 

- We therefore use the Compute Canada cluster (http://www.computecanada.ca) as described next. 


- First, we need to install the SLiM software. The way we install the software is exactly the same as  how we install the software on our own computer. Use the SLiM manual guidelines for this task. 

- After we install SLiM, we use a job scheduler in the cluster to run our jobs.

- In the Compute Canada Cluster we use the **Slurm Workload Manager** as the job scheduler. 

- Slurm helps to allocate resources and time, and provides methods to execute our work.

- To run the SLiM script we use a Slurm script as follows. 


```{bash, eval = FALSE}
#!/bin/bash
#SBATCH --account=def-jgraham
#SBATCH --ntasks=1
#SBATCH --time=7-05:05:00
#SBATCH --mem=64000M    

module load StdEnv/2020 gcc/9.3.0 slim/3.4.0
 
slim SLiM_American_Admixture.slim

```

- Let's understand each line of the above batch script file. 

- \texttt{\#SBATCH--account=def-jgraham} - specifies the account name. In this example, the account name is "def-jgraham".

- \texttt{\#SBATCH--ntasks=1} - defines the number of processors. We request 1 processor to run the program. 

- \texttt{\#SBATCH--time=7-05:05:00}- specifies the time limit for the job. Usually, we allocate a time which is more than the expected time to run the program. This is because, if our simulation takes a longer time than the allocated time, the simulation will stop without executing when the given time limit is achieved.

- \texttt{\#SBATCH--mem=640000M} - specifies memory that we require to run our simulation. We request 64GB. 

-  Next, the executable commands are aligned in the script file. They are:

- \texttt{module load StdEnv/2020 gcc/9.3.0 slim/3.4.0} - loads the SLiM version  which we installed.

- \texttt{slim SLiM\_American\_Admixture.slim}- calls for SLiM to run the SLiM script file: \texttt{SLiM\_American\_Admixture.slim}. This is the final command in the slurm script file.


- Then we use \texttt{sbatch} command to submit above slurm script file to run in the cluster. We type the \texttt{sbatch} command in our log in node as follows. 



```{bash, eval = FALSE}
[epasiedn@gra-login2 American_Admixture]$ sbatch job_serial.sh

```


- This simulation took approximately 3 days to complete. 

- In our job script we allocate 64GB to run the simulation. Out of this 64GB, the job utilized 43.61GB. 

- The output of this SLiM model is saved as \texttt{SLiM\_output.txt} and we use this file as one of the inputs for the third phase of our work flow.

- We will examine the \texttt{SLiM\_output.txt} output in our third R-markdown document.

## Summary Statistics

- We obtain summary statistics of the American admixed population by using the SLiM output. 

```{r}
library(SimRVSequences)
library(tidyverse)
library(Matrix)
library(data.table)

# Read the SLiM output text file to R
exDat <- readLines("D:/SFU_Vault/SLiM_Output/Output_Full.txt")


```

- The \texttt{SLiM\_output.txt} file size is approximately 6 GB.

- We read the \texttt{SLiM\_output.txt} file to R and it takes approximately 1 minute to load to R on a Windows OS with an i7-8550U @ 1.8GHz,16GB of RAM.

```{r}
# Read the mutations and genomic sections in the output
MutHead <- which(exDat == "Mutations:")
GenHead <- which(exDat == "Genomes:")

# Get the population count in sequences
popCount <- as.numeric(unlist(strsplit(exDat[1], 
                                       split = " ", fixed = TRUE))[4])

# Population count in individuals
popCount/2

```

- The size of the simulated American admixed population is 53,876.

```{r}
# Extract mutation data from sLiM's Mutation output
# only retaining the tempID, type, position,
# selection coefficient and count of each mutation
MutOut <- do.call(rbind, strsplit(exDat[(MutHead + 1):(GenHead - 1)], split = " ", fixed = TRUE))
MutData <- data.frame(tempID = as.numeric(MutOut[, 1]),
                      type = MutOut[, 3],
                      position = as.numeric(MutOut[, 4]),
                      selCoef = as.numeric(MutOut[, 5]),
                      count = as.numeric(MutOut[, 9]),
                      stringsAsFactors = TRUE)

nrow(MutData)

```

- There are 862,243 number of mutations are currently segregating in the admixed population. 

- Then we examine among these 862,243 mutations the percentage of allele frequency less than 1% in the population. 

```{r}
# Add 1 to temp ID so that we can easily associate mutations to columns.
# By default SLiM's first tempID is 0, not 1.
MutData$tempID <- MutData$tempID + 1
# First position in SLiM is 0, not 1
MutData$position <- MutData$position + 1

# Calculate the population derived allele frequency.
# Divide the allele count by the population size. 
MutData$afreq <- MutData$count/(popCount)

# Get the percentage of SNVs whose allele frequency < 0.01
af_less <- which(MutData$afreq < 0.01)
af_less_per <- length(af_less)/ nrow(MutData)

af_less_per

```

- Among these mutations, approximately 94% have frequencies less than 1%.

- We compare these results with the TopMed study [@Taliun2021]. The TopMed study has newly released empirical results for the American population and suggests that the majority of variants have alternate allele frequencies of less than 1%. According to @Taliun2021, approximately 97% of variants in the TopMed Study are rare (i.e. have allele frequencies less than 1%). 

- In our American admixed population also, we find that approximately 94% of the mutations are rare.

- We use the following code chuck to check the singleton percentage in the American admixed population.

```{r}

# Use the prevalence (the number of times that the mutation occurs in any genome) 
# column in MutData dataframe to calculate the singleton percentage
singelton <- MutData %>% 
  count(count) %>%
  mutate(percentage = n/nrow(MutData))

colnames(singelton) <- c("number_of_allele", "count", "proportion")
head(singelton)

```

- Among 862,243 mutations, 19% of them are singletons. The following figure illustrates the allele frequency spectrum.

```{r, warning=FALSE}
# Plot the first 50 sites in the allele frequency spectrum
ggplot(singelton) + 
  geom_bar(mapping = aes(x = as.factor(number_of_allele), 
                                           y = proportion), 
                             stat="identity",
                             position="dodge") +
  xlab("Allele Count") + 
  ylab("Proportion") +
  ylim(0, 0.3) + 
  scale_x_discrete(limits= as.character(1:50))

```

- In the TopMed study, about half of the variants are singletons [@Taliun2021].

- The reason for the discrepancy between our results and TopMed is our lack of source populations. In our SLiM model we have only three source populations and we collect SNV data from the American admixed population only. But in the TopMed study, they consider the entire American population which consists of many more source populations. 

- To check this, we combine data from all four populations in our SLiM model and check if the singleton percentage is increased. Due to the high computational cost we only simulate data from chromosome 8 and 9. 

- Combining all four populations, around 26% of variants are singletons. 

- The supplementary material 1-B discusses the commands to generate and summarize all the source populations and check the proportions of singletons after combining the four populations. 

\newpage

# Reference
